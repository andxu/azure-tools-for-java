plugins {
    id "org.jetbrains.intellij" version "0.4.5"
    id "org.jetbrains.kotlin.jvm" version "1.2.50"
    id "de.undercouch.download" version "4.0.1"
}

import org.apache.tools.ant.filters.*
import groovy.json.JsonSlurper

processResources {
    filesMatching('**/ApplicationInsights.xml') {
        filter(ReplaceTokens, tokens: ["applicationinsights.key": project.property("applicationinsights.key")])
    }
}

group 'com.microsoft.azuretools'

compileJava {
    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion
}

compileKotlin {
    kotlinOptions.jvmTarget = javaVersion
}
compileTestKotlin {
    kotlinOptions.jvmTarget = javaVersion
}

tasks.withType(JavaCompile) { options.encoding = 'UTF-8' }

apply plugin: 'checkstyle'
apply plugin: 'findbugs'

checkstyle {
    toolVersion = '8.24'
    configFile = new File('config/checkstyle/checkstyle.xml')
    showViolations = false
}

findbugs {
    toolVersion = "3.0.1"
    ignoreFailures = true
}

intellij {
    pluginName = 'azure-toolkit-for-intellij'
    version = intellij_version
    updateSinceUntilBuild = Boolean.valueOf(updateVersionRange)
    plugins = intellij_version == "IC-2019.1" ? ['maven', dep_plugins, "properties"] : ['java', 'maven', dep_plugins, "properties"]
	downloadSources = Boolean.valueOf(sources)
}

sourceSets {
    main {
        java.srcDirs 'src'
        kotlin.srcDirs 'src'
        resources {
            srcDir 'resources'
            exclude 'bundle/**'
        }
    }
    test {
        java {
            srcDir 'Test/java'
        }
        kotlin.srcDirs 'Test/java'
        resources {
            srcDir 'Test/resources'
        }
    }
}

repositories {
    maven {url uri('../../.repository')} // to snap to the private maven repo on Jenkins if any
    mavenLocal()
    mavenCentral()
}

configurations {
    compile.exclude module:'slf4j-api'
    compile.exclude module:'log4j'
    cucumberRuntime {
        extendsFrom testRuntime
    }
}

apply plugin: 'java'

dependencies {
    compile fileTree(dir: '../AddLibrary/AzureLibraries/com.microsoft.azuretools.sdk/dependencies', include: ['applicationinsights-management-1.0.3.jar'])
    compile 'com.microsoft.sqlserver:mssql-jdbc:6.1.0.jre8'
    compile 'commons-io:commons-io:2.5'
    compile 'net.minidev:json-smart:2.3'
    compile 'com.microsoft.azure:azure-client-runtime:1.6.13', { force = true }
    compile 'com.microsoft.azure:azure-client-authentication:1.6.13', { force = true }
    compile 'com.microsoft.azuretools:azuretools-core:3.31.0', {
        exclude group: "com.microsoft.azure", module: "azure-client-authentication"
        exclude group: "com.microsoft.azure", module: "azure-client-runtime"
        exclude group: "javax.xml.bind", module: "jaxb-api"
    }
    compile 'com.microsoft.azuretools:azure-explorer-common:3.31.0', {
        exclude group: "com.microsoft.azure", module: "azure-client-authentication"
        exclude group: "com.microsoft.azure", module: "azure-client-runtime"
        exclude group: "javax.xml.bind", module: "jaxb-api"
    }
    compile 'com.microsoft.azuretools:hdinsight-node-common:3.31.0', {
        exclude group: "com.microsoft.azure", module: "azure-client-authentication"
        exclude group: "com.microsoft.azure", module: "azure-client-runtime"
        exclude group: "javax.xml.bind", module: "jaxb-api"
    }
    compile 'com.spotify:docker-client:8.11.7'

    testCompile 'junit:junit:4.12'
    testCompile 'info.cukes:cucumber-junit:1.2.5'
    testCompile 'info.cukes:cucumber-java:1.2.5'
    testCompile 'org.mockito:mockito-core:2.7.22'
    testCompile 'org.assertj:assertj-swing-junit:3.5.0'

    testCompile 'com.github.tomakehurst:wiremock:2.8.0'
    testCompile 'org.powermock:powermock-module-junit4:1.7.0RC4'
    testCompile 'org.powermock:powermock-api-mockito2:1.7.0RC4'
    testCompile 'javax.servlet:javax.servlet-api:3.1.0'

    testCompile "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    testCompile "org.jetbrains.kotlin:kotlin-test"
    testCompile "org.jetbrains.kotlin:kotlin-test-junit"
}

test {
    testLogging.showStandardStreams = true
    testLogging {
        events "passed", "skipped", "failed"
    }
} 

task cucumberPackJar(type: Jar) {
    appendix = 'pathing'

    doFirst {
        manifest {
            attributes "Class-Path": configurations.cucumberRuntime.files.collect {
                it.toURI().toString().replaceFirst(/file:\/+/, '/')
            }.join(' ')
        }
    }
}

buildSearchableOptions.onlyIf {false}

task cucumber() {
    dependsOn compileTestJava, cucumberPackJar
    doLast {
        javaexec {
            main = "cucumber.api.cli.Main"
            classpath = files(sourceSets.main.output, sourceSets.test.output, cucumberPackJar.archivePath)
            args = [
                '--plugin', 'progress',
                '--glue', 'com.microsoft.azure.hdinsight.spark.common',
                '-m',
                'Test/resources']
        }
    }
}

test.dependsOn cucumber
// buildPlugin.dependsOn test

defaultTasks 'buildPlugin'

task wrapper(type: Wrapper) {
    gradleVersion = '4.8'
    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
}

def bundleConfig = [
        // Downloading resources
        jdkUrl:             "",
        jbrUrl:             "https://jetbrains.bintray.com/intellij-jbr/jbrx-8u232-windows-x64-b1638.6.tar.gz",
        scalaSdkUrl:        "https://downloads.lightbend.com/scala/2.11.12/scala-2.11.12.zip",
        winutilsUrl:        "https://github.com/steveloughran/winutils/archive/tag_2017-08=29-hadoop-2.8.1-native.zip",
        adoptOpenJdkApi:    "https://api.adoptopenjdk.net/v2/info/releases/openjdk8?os=windows&arch=x64&type=jdk&openjdk_impl=hotspot&release=latest",

        winutilsVer:        "hadoop-2.7.1",
        scalaVer:           "2.11.12",

        // Dir configuration
        bundleBuildDir:     new File(buildDir, "bundle").toString(),
        downloadedOptsDir:  new File(buildDir, "bundle-opts").toString(),
        optDir:             new File(buildDir, "bundle/opt").toString(),
        bundleResourceDir:  file("resources/bundle").toString(),
        bundleTemplateDir:  file("resources/bundle/template").toString(),

        // Opt dir
        jdkDir:             "",
        scalaSdkDir:        "",
        winutilsDir:        "",

        END:                ""
]


//def bundleDirPath = bundleDir.absolutePath

task installIntelliJ {
    dependsOn buildPlugin

    doLast {
        println "IntelliJ IDEA binary: " + intellij.ideaDependency.classes
        println "Spark development bundle bits target directory: " + bundleConfig.bundleBuildDir

        def ideaBat = new File(bundleConfig.bundleBuildDir, "bin/idea.bat")

        if (!ideaBat.exists()) {
            copy {
                from intellij.ideaDependency.classes
                into bundleConfig.bundleBuildDir
            }
        } else {
            println "idea.bat file existed, ignore copying."
        }
    }
}

task getJdkUrl {
    doLast {
        if (bundleConfig.jdkUrl?.isEmpty()) {
            def httpcon = new URL(bundleConfig.adoptOpenJdkApi).openConnection()
            httpcon.addRequestProperty("User-Agent", "Mozilla")
            def adoptOpenJdk = new JsonSlurper().parseText(httpcon.getInputStream().getText())

            bundleConfig.jdkUrl = adoptOpenJdk["binaries"][0]["binary_link"]
        }
    }
}

task downloadOpts {
    dependsOn getJdkUrl

    doLast {
        println "Download OPT dependencies into " + bundleConfig.downloadedOptsDir
        mkdir bundleConfig.downloadedOptsDir

        for (dep in bundleConfig.subMap(["jdkUrl", "jbrUrl", "scalaSdkUrl", "winutilsUrl"]).values()) {
            download {
                src dep
                dest bundleConfig.downloadedOptsDir
                onlyIfModified true
            }
        }
    }
}

//def optRelativeDir = new RelativePath(false, "opt")
//def winutilsRelativeDir = optRelativeDir.append(false, bundleConfig.winutilsVer)

task unzipOptWinutils {
    doLast {
        copy {
            from zipTree(new File(bundleConfig.downloadedOptsDir, new File(new URL(bundleConfig.winutilsUrl).file).name))
            into bundleConfig.optDir
            include "/*/" + bundleConfig.winutilsVer + "/**/*"
            eachFile { FileCopyDetails fileCopyDetail ->
                fileCopyDetail.relativePath = new RelativePath(true, fileCopyDetail.relativePath.segments.drop(1))
                if (bundleConfig.winutilsDir?.isEmpty()) {
                    bundleConfig.winutilsDir = new File(bundleConfig.optDir, fileCopyDetail.relativePath.segments[0]).toString()
                }
            }
            includeEmptyDirs = false
        }
    }
}

task prepareJbr(type: Copy) {
    dependsOn downloadOpts

    from tarTree(resources.gzip(new File(bundleConfig.downloadedOptsDir, new File(new URL(bundleConfig.jbrUrl).file).name)))
    into bundleConfig.bundleBuildDir
}

ext.printBundleConfig = { ->
    println "Bundle configuration:"
    bundleConfig.forEach { key, value -> println "$key ==> $value" }
}

task unzipOpts {
    dependsOn downloadOpts
    // complex unzip
    dependsOn unzipOptWinutils

    doLast {
        // Fast unzip with default options
        def fastUnzipOptFilenames2Type = ["jdk", "scalaSdk"]
                .collectEntries { [ (new File(new URL(bundleConfig[it + "Url"]).file).name) : it ] }

        for (zipFile in file(bundleConfig.downloadedOptsDir).listFiles()) {
            // Only unzip selected zip files
            if (!fastUnzipOptFilenames2Type.containsKey(zipFile.name)) {
                continue
            }

            copy {
                from zipTree(zipFile.absolutePath)
                into bundleConfig.optDir
                eachFile { FileCopyDetails fileCopyDetail ->
                    def unzipDir = fastUnzipOptFilenames2Type[zipFile.name] + "Dir"

                    if (bundleConfig[unzipDir]?.isEmpty()) {
                        bundleConfig[unzipDir] =
                                new File(bundleConfig.optDir, fileCopyDetail.relativePath.segments[0]).toString()
                    }
                }
            }
        }

        printBundleConfig()
    }
}

task copyRunme(type: Copy) {
    dependsOn installIntelliJ, unzipOpts

    from bundleConfig.bundleTemplateDir
    into bundleConfig.bundleBuildDir
    expand bundleConfig
}

task installPlugins(type: Copy) {
    dependsOn installIntelliJ
    
    from new File(intellij.sandboxDirectory, "plugins")
    into new File(bundleConfig.bundleBuildDir, "config/plugins")
}

task buildBundleForSparkTask(type: Zip) {
    dependsOn installIntelliJ, downloadOpts, unzipOpts, installPlugins, copyRunme, prepareJbr

    from fileTree(dir: bundleConfig.bundleBuildDir)
    archiveName "idea${intellij_version}-bundle-win-x64.zip"
    destinationDir file("$buildDir/distributions")
    exclude "bin/mac/**", "bin/linux/**", "MacOS/**", "plugins/android/**"
    entryCompression ZipEntryCompression.STORED
}
